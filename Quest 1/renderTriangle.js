// function _0x3e6f(_0x403729,_0x1fc96f){const _0x3dbc4d=_0x3dbc();return _0x3e6f=function(_0x3e6fe4,_0x7d990b){_0x3e6fe4=_0x3e6fe4-0x72;let _0xc87f30=_0x3dbc4d[_0x3e6fe4];return _0xc87f30;},_0x3e6f(_0x403729,_0x1fc96f);}const _0x4d3704=_0x3e6f;(function(_0x9b3154,_0x7f5758){const _0x3feaa6=_0x3e6f,_0x4dd5db=_0x9b3154();while(!![]){try{const _0x1c0acf=-parseInt(_0x3feaa6(0x84))/0x1*(-parseInt(_0x3feaa6(0x9f))/0x2)+parseInt(_0x3feaa6(0x7d))/0x3*(parseInt(_0x3feaa6(0x80))/0x4)+parseInt(_0x3feaa6(0x91))/0x5*(parseInt(_0x3feaa6(0x8d))/0x6)+-parseInt(_0x3feaa6(0x7e))/0x7+-parseInt(_0x3feaa6(0xac))/0x8+parseInt(_0x3feaa6(0x90))/0x9+-parseInt(_0x3feaa6(0x94))/0xa;if(_0x1c0acf===_0x7f5758)break;else _0x4dd5db['push'](_0x4dd5db['shift']());}catch(_0x262c3a){_0x4dd5db['push'](_0x4dd5db['shift']());}}}(_0x3dbc,0xe6b78));async function _0x43a383(){const _0x3af4d1=_0x3e6f,_0xe6c4ae=document[_0x3af4d1(0x97)]('canvas');_0xe6c4ae['id']=_0x3af4d1(0x82),document[_0x3af4d1(0x8f)][_0x3af4d1(0x95)](_0xe6c4ae);const _0x138b22=window[_0x3af4d1(0xa3)]||0x1,_0xa7a0df=window['innerWidth']*_0x138b22,_0x1e024e=window[_0x3af4d1(0x8a)]*_0x138b22;if(_0xe6c4ae[_0x3af4d1(0xab)]=_0xa7a0df,_0xe6c4ae[_0x3af4d1(0x9e)]=_0x1e024e,_0xe6c4ae['style'][_0x3af4d1(0xab)]=window[_0x3af4d1(0x9d)]+'px',_0xe6c4ae[_0x3af4d1(0x74)][_0x3af4d1(0x9e)]=window[_0x3af4d1(0x8a)]+'px',!navigator[_0x3af4d1(0xa8)])throw Error(_0x3af4d1(0x73));const _0xbfb51a=await navigator[_0x3af4d1(0xa8)][_0x3af4d1(0x78)]();if(!_0xbfb51a)throw Error(_0x3af4d1(0x93));const _0x2726f5=await _0xbfb51a[_0x3af4d1(0x92)](),_0x87be6e=_0xe6c4ae[_0x3af4d1(0x83)](_0x3af4d1(0xa4)),_0x2eb8c0=navigator['gpu'][_0x3af4d1(0x88)]();_0x87be6e['configure']({'device':_0x2726f5,'format':_0x2eb8c0});const _0x203a64=_0x2726f5[_0x3af4d1(0xa2)](),_0x584100=_0x203a64[_0x3af4d1(0x85)]({'colorAttachments':[{'view':_0x87be6e[_0x3af4d1(0xa7)]()['createView'](),'clearValue':{'r':0x0,'g':0x38/0xff,'b':0x65/0xff,'a':0x1},'loadOp':_0x3af4d1(0x9b),'storeOp':_0x3af4d1(0x9c)}]});var _0x5c0447=_0x2726f5[_0x3af4d1(0x8b)]({'label':_0x3af4d1(0xad),'code':_0x3af4d1(0xa9)}),_0x2e3dd9=new Float32Array([0x0,0.5,-0.5,0x0,0.5,0x0]),_0x436c62=_0x2726f5['createBuffer']({'label':_0x3af4d1(0x99),'size':_0x2e3dd9[_0x3af4d1(0x81)],'usage':GPUBufferUsage[_0x3af4d1(0x72)]|GPUBufferUsage[_0x3af4d1(0xaa)]});_0x2726f5[_0x3af4d1(0x8e)][_0x3af4d1(0xa6)](_0x436c62,0x0,_0x2e3dd9);var _0x4d78f2={'arrayStride':0x2*Float32Array[_0x3af4d1(0x7f)],'attributes':[{'format':_0x3af4d1(0x96),'offset':0x0,'shaderLocation':0x0}]},_0x71d4ff=_0x2726f5[_0x3af4d1(0x75)]({'label':_0x3af4d1(0x98),'layout':_0x3af4d1(0x77),'vertex':{'module':_0x5c0447,'entryPoint':_0x3af4d1(0x89),'buffers':[_0x4d78f2]},'fragment':{'module':_0x5c0447,'entryPoint':'fragmentMain','targets':[{'format':_0x2eb8c0}]}});_0x584100[_0x3af4d1(0x86)](_0x71d4ff),_0x584100[_0x3af4d1(0x8c)](0x0,_0x436c62),_0x584100[_0x3af4d1(0x7a)](_0x2e3dd9['length']/0x2),_0x584100[_0x3af4d1(0x87)]();const _0x108479=_0x203a64[_0x3af4d1(0x7b)]();return _0x2726f5[_0x3af4d1(0x8e)][_0x3af4d1(0x76)]([_0x108479]),_0x87be6e;}_0x43a383()[_0x4d3704(0x79)](_0x15aa00=>{})[_0x4d3704(0xa1)](_0x84308a=>{const _0xa57e35=_0x4d3704,_0x2aac78=document[_0xa57e35(0x97)]('p');_0x2aac78[_0xa57e35(0xa5)]=navigator[_0xa57e35(0x9a)]+_0xa57e35(0xa0)+_0x84308a['message'],document['body'][_0xa57e35(0x95)](_0x2aac78),document[_0xa57e35(0x7c)](_0xa57e35(0x82))['remove']();});function _0x3dbc(){const _0x42b60c=['renderCanvas','getContext','21356ILfBDh','beginRenderPass','setPipeline','end','getPreferredCanvasFormat','vertexMain','innerHeight','createShaderModule','setVertexBuffer','8572092lBhJNJ','queue','body','12256155gJVHJv','5AXgaPs','requestDevice','Couldn\x27t\x20request\x20WebGPU\x20adapter.','11520890aafQRU','appendChild','float32x2','createElement','Render\x20Pipeline','Vertices','userAgent','clear','store','innerWidth','height','102cEvJlk','</br>','catch','createCommandEncoder','devicePixelRatio','webgpu','innerHTML','writeBuffer','getCurrentTexture','gpu','\x0a\x20\x20@vertex\x20//\x20this\x20compute\x20the\x20scene\x20coordinate\x20of\x20each\x20input\x20vertex\x0a\x20\x20fn\x20vertexMain(@location(0)\x20pos:\x20vec2f)\x20->\x20@builtin(position)\x20vec4f\x20{\x0a\x20\x20\x20\x20return\x20vec4f(pos,\x200,\x201);\x20//\x20(pos,\x20Z,\x20W)\x20=\x20(X,\x20Y,\x20Z,\x20W)\x0a\x20\x20}\x0a\x20\x20\x0a\x0a\x20\x20@fragment\x20//\x20this\x20compute\x20the\x20color\x20of\x20each\x20pixel\x0a\x20\x20fn\x20fragmentMain()\x20->\x20@location(0)\x20vec4f\x20{\x0a\x20\x20\x20\x20return\x20vec4f(238.f/255,\x20118.f/255,\x2035.f/255,\x201);\x20//\x20(R,\x20G,\x20B,\x20A)\x0a\x20\x20}\x0a\x20\x20','COPY_DST','width','11488560oBFbKL','Shader','VERTEX','WebGPU\x20is\x20not\x20supported\x20in\x20this\x20browser.','style','createRenderPipeline','submit','auto','requestAdapter','then','draw','finish','getElementById','29301EVPLje','12748925RLIrQp','BYTES_PER_ELEMENT','604JFKCvl','byteLength'];_0x3dbc=function(){return _0x42b60c;};return _0x3dbc();}

async function init() {
  // Create a canvas tag
  const canvasTag = document.createElement('canvas');
  canvasTag.id = "renderCanvas";
  document.body.appendChild(canvasTag);
  // Modify the canvas size
  const devicePixelRatio = window.devicePixelRatio || 1;
  const width = window.innerWidth * devicePixelRatio;
  const height = window.innerHeight * devicePixelRatio;
  canvasTag.width = width;
  canvasTag.height = height; 
  // Modify the canvas using CSS
  canvasTag.style.width = `${window.innerWidth}px`;
  canvasTag.style.height = `${window.innerHeight}px`;
  // Check if it supports WebGPU
  if (!navigator.gpu) {
    throw Error("WebGPU is not supported in this browser.");
  }
  // Get an GPU adapter
  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    throw Error("Couldn't request WebGPU adapter.");
  }
  // Get a GPU device
  const device = await adapter.requestDevice();
  // Get canvas context using webgpu
  const context = canvasTag.getContext("webgpu");
  const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
  context.configure({
    device: device,
    format: canvasFormat,
  });
  // Create a gpu command encoder
  const encoder = device.createCommandEncoder();
  // Use the encoder to begin render pass
  const pass = encoder.beginRenderPass({
    colorAttachments: [{
      view: context.getCurrentTexture().createView(),
      // clearValue: { r: 0, g: 56/255, b: 101/255, a: 1 }, // Bucknell Blue
      clearValue: { r: 200, g: 16/255, b: 46/255, a: 1 },
      loadOp: "clear",
      storeOp: "store",
    }]
  });
  // Vertex shader
  var vertCode = `
  @vertex // this compute the scene coordinate of each input vertex
  fn vertexMain(@location(0) pos: vec2f) -> @builtin(position) vec4f {
    return vec4f(pos, 0, 1); // (pos, Z, W) = (X, Y, Z, W)
  }
  `;
  // Fragment shader
  var fragCode = `
  @fragment // this compute the color of each pixel
  fn fragmentMain() -> @location(0) vec4f {
    return vec4f(255.f/255, 205.f/255, 0.f/255, 1); // (R, G, B, A)
  }
  `;
  // return vec4f(238.f/255, 118.f/255, 35.f/255, 1); // (R, G, B, A)
  // Create shader module
  var shaderModule = device.createShaderModule({
    label: "Shader",
    code: vertCode + '\n' + fragCode,
  }); 
  // Create a triangle geometry in CPU
  var vertices = new Float32Array([
     // x, y
    //  0.5, 0.5,
    //  0.5, -0.5,
    //  -0.5, 0.5,

    //  -0.5, -0.5,
    //  0.5, -0.5,
    //  -0.5, 0.5,

    0,0, //Top
    0,0.5,
    0.117,0.151,

    0,0,
    0,0.5,
    -0.117,0.151,

    0,0, //Left
    -0.4755,0.1545,
    -0.10745,0.15794,

    0,0,
    -0.4755, 0.1545,
    -0.17976, -0.06461,

    0,0, //Right
    -0.2939,-0.4045,
    -0.1834,-0.05339,

    0,0,
    -0.2939,-0.4045,
    0.0059,-0.19093,
    
    0,0, // Left Bot
    0.2939,-0.4045,
    -0.0059,-0.19093,

    0,0,
    0.2939,-0.4045,
    0.1834,-0.05339,

    0,0, //Right Bot
    0.4755, 0.1545,
    0.17976, -0.06461,

    0,0,
    0.4755, 0.1545,
    0.10745, 0.15794,

  ]);

  // Create vertex buffer to store the vertices in GPU
  var vertexBuffer = device.createBuffer({
    label: "Vertices",
    size: vertices.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  // Copy from CPU to GPU
  device.queue.writeBuffer(vertexBuffer, 0, vertices);
  // Defne vertex buffer layout - how the shader should read the buffer
  var vertexBufferLayout = {
    arrayStride: 2 * Float32Array.BYTES_PER_ELEMENT,
    attributes: [{
      format: "float32x2", // 32 bits, each has two coordiantes
      offset: 0,
      shaderLocation: 0, // position in the vertex shader
    }],
  };
  // Use the module to create a render pipeline
  var renderPipeline = device.createRenderPipeline({
    label: "Render Pipeline",
    layout: "auto", // we will talk about layout later
    vertex: {
      module: shaderModule,         // the shader module
      entryPoint: "vertexMain",     // where the vertex shader starts
      buffers: [vertexBufferLayout] // the buffer layout - more about it soon
    },
    fragment: {
      module: shaderModule,         // the shader module
      entryPoint: "fragmentMain",   // where the fragment shader starts
      targets: [{
        format: canvasFormat        // the target canvas format (the output)
      }]
    }
  }); 
  // add more render pass to draw the plane
  pass.setPipeline(renderPipeline);      // which render pipeline to use
  pass.setVertexBuffer(0, vertexBuffer); // which vertex buffer is used at location 0
  pass.draw(vertices.length / 2);        // how many vertices to draw
  pass.end(); // end the pass
  // Create the command buffer
  const commandBuffer = encoder.finish();
  // Submit to the device to render
  device.queue.submit([commandBuffer]);
  return context;
}

init().then( ret => {
  console.log(ret);
}).catch( error => {
  const pTag = document.createElement('p');
  pTag.innerHTML = navigator.userAgent + "</br>" + error.message;
  document.body.appendChild(pTag);
  document.getElementById("renderCanvas").remove();
});